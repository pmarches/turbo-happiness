turbo-happiness
===============

Yet another attempt at a Tag based filesystem. The files and folder paradigm has served us well, but it is time to move on. Humans do not naturaly organize their data in a hiarchical manner. Many people have imagined tag based filesystems with little success. Here is our stab at it.

The main realization is that today we use already use tag based filesystems. For example, we tag the bash binary with the label "usr", "local" and "bin". Is there really any difference between /usr/local/bin/bash and /bin/local/usr/bash? A hiearchy of tags is not necessary to find the data we need. Today, a human may organize Photos by date, event, people, location, or a mix of all of this. The end result is a mess that is patched over with the help of search engines.

Automatic tags
--------
Manually tagging each file is a tedious process. Some tags are more like properties of documents. For example, the language a document is written in. The format (word, excel, ...) 

Search engines
-------
Haven't desktop search engines solved this problem already? Are you using a desktop search engine? No? Neither am I. Why is that? Natural language search engines will dig up a good enough website based on what you are searching for. They will not guide you to the best resource you need, but to the one that is good enough. When you are looking for a document, your are not looking for a document that is close enough, you are looking for exactly one document.

To start searching for a document, you remember some particulars of the document. When enough particulars are cross-referenced, you just found your document. turbo-hapiness will match a large initial set of documents with the first tag. Each document from that first set has additional tags that may used in a second level search. Prompting the user with the second set of tags will help the user remember what other tag the document may have. Each additional tag selection will reduce the set of candidate documents.

Markov chain
---
Does this apply???

Implementation
--------

 - Garbage collection
 - Use of existing FS
 - 

Objects in tagfs
--------
 - Files (I prefer blob but to ease understanding let's use file)
  - Each file has a random unique id (UniqueBlobId) 512 bit long
  - The files are mutable
  - Files may be accessed with their UBI. ex: fopen("UBI-GOES-HERE"); or by their tags and names
  - UBI is kept for all of the file's life, across systems. Meaning, the UBI generated by the developper when writing some file will be the same UBI that is installed on that customer's machine. 

 - Attributes
	- types include String, Numbers, Date, Lists?, Attribute?, UBI?
	- Mandatory attribute called name (String)

 - Tags
  - Each tag has a unique ID (512 bit)
  - Are tags attributes with an empty value?
  - Tags have a human redable name
 
 - Tagset


File (blob) operations
--------

 - Copy
 - Move
 - Delete

Security
--------
 - ACL as attributes
 - What operations can be perfomed on the file


Uses of tags
--------

 - Each software vendor has it's own tag
 - Each software version has it's own tag
 - Makes it easy to figure who is using what file (How does that tie into package management?)
 - 

Legacy compatibility
--------

Supporting traditional filesystem is key for widespread adoption of a tag based FS. In traditional filesystems, each path element is a tag. The ordering does not matter. 

 - fopen compatibility is possible by converting a string path into a set of tags.
 - Mountable filesystem start at the root by showing all the tags available. When you change "directory" to one of the tags, the ls command will reveal only the tags for which there exists a file with the current tag and the additional tags. Changing directory to a second tag, will show only files that have both tags and the next tags. When enough attributes have been specified to uniquely identify a blob, the blob is shown as a file, ready to be opened. The filename 
 - File browser

File names
------
One problem to overcome, is to determine how to name files. File names unique within a directory is a concept that applies only in HFS. In THFS, there is no such concept as a file name. A file is identified by the composition of it's attributes. "budget 2014 canada" maps to 3 tags. We need to add more tags or attributes to uniquely identity each file.

Attributes, Tags
--

* User Attributes
  * Tag : (Attribute name only, no value associated) The most user-centric way of organizing files.
  * Date attribute: Ex: {Approved:March 2009}
  * Integer tag
  * String tag
  * Composite : A tag comprised of multiple attributes. 
* System generated Attributes 
  * Creation date : Attribute and date
  * Content hash : Attribute and String
  * Predecessor hash: Attribute and String
  * Version number: Attribute and Integer
  * mime/type : Attribute and String
  * Size (integer) : Attribute and integer
  * Creation UUID: Attribute and String. Random ID generated when the file is created. Does not change when the file is modified, but changes if saved with "Save As" dialog.
* ChronoTag
  * A tag with an associated date. Ex: "European tour 2013"

Binary search on dates
--
What did you do on March 23 2013? Of course, you do not remember, however you may remember if it is before or after you went on that cruise. When searching for a date, it is easier to do a binary search relative to events. Ex: You are looking for a file modified before or after that cruise? the ChronoTag shown are the ones that best bound the candidate files. These candidates may have been bounded by other criterias.

Attribute search
--


Zipping indexes
---

